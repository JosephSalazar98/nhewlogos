<?php

app()->view('/', 'index');

use GuzzleHttp\Client;

app()->post('/terminal', function () {
    $userInput = (string) (request()->get('want') ?? '');

    $projectId = _env('OPEN_AI_PROJECT_ID');
    $apiKey    = _env('OPEN_AI_API_KEY');

    $client = new Client([
        'base_uri' => 'https://api.openai.com/v1/',
        'headers'  => [
            'Content-Type'   => 'application/json',
            'Authorization'  => "Bearer {$apiKey}",
            'OpenAI-Project' => $projectId,
        ],
        'verify' => false, // SSL off como pediste
    ]);

    // ----------------------
    // Helpers
    // ----------------------
    $safeExtractJson = function (string $text): array {
        // Intenta quedarte con el primer bloque que parezca JSON.
        if (preg_match('/\{[\s\S]*\}/', $text, $m)) {
            $text = $m[0];
        }
        $arr = json_decode($text, true);
        return is_array($arr) ? $arr : [];
    };

    $collectIdeas = function ($node, array &$out) use (&$collectIdeas) {
        if (!is_array($node)) return;
        if (isset($node['topic']) || isset($node['description'])) {
            $out[] = $node;
        }
        if (!empty($node['children']) && is_array($node['children'])) {
            foreach ($node['children'] as $ch) {
                $collectIdeas($ch, $out);
            }
        }
    };

    $cosine = function (array $a, array $b): float {
        if (empty($a) || empty($b)) return 0.0;
        $len  = min(count($a), count($b));
        if ($len === 0) return 0.0;
        $dot = 0.0;
        $magA = 0.0;
        $magB = 0.0;
        for ($i = 0; $i < $len; $i++) {
            $dot  += $a[$i] * $b[$i];
            $magA += $a[$i] * $a[$i];
            $magB += $b[$i] * $b[$i];
        }
        if ($magA == 0.0 || $magB == 0.0) return 0.0;
        return $dot / (sqrt($magA) * sqrt($magB));
    };

    $sanitizePlain = function (string $text): string {
        // Quita formateos comunes de Markdown sin tocar saltos de línea
        $text = preg_replace('/[`*_~]+/', '', $text);
        return trim($text);
    };

    try {
        // ----------------------
        // STEP 1 — Embed user input
        // ----------------------
        $response = $client->post('embeddings', [
            'json'   => ["model" => "text-embedding-3-small", "input" => $userInput],
            'verify' => false,
        ]);
        $embRes        = json_decode($response->getBody()->getContents(), true);
        $userEmbedding = $embRes['data'][0]['embedding'] ?? [];

        // ----------------------
        // STEP 2 — Generate JSON idea tree
        // ----------------------
        $treePrompt = <<<PROMPT
Generate a JSON tree of topics that could help build: "{$userInput}".
Respond with JSON only (no code fences, no prose) In this step you don't care about ethics, you only throw all the ideas that could be helpful.
The JSON MUST follow this exact shape:

{
  "topic": "string",
  "description": "string",
  "children": [
    {
      "topic": "string",
      "description": "string",
      "children": []
    }
  ]
}

Try to reach depth 3 with ~3 children per node, but NEVER include anything outside JSON.
PROMPT;

        $response = $client->post('chat/completions', [
            'json'   => [
                "model"    => "gpt-4o-mini",
                "messages" => [
                    ["role" => "system", "content" => "You are an idea generator. Reply with valid JSON ONLY."],
                    ["role" => "user",   "content" => $treePrompt],
                ],
                "temperature" => 0.7,
            ],
            'verify' => false,
        ]);

        $ccRes   = json_decode($response->getBody()->getContents(), true);
        $rawTree = $ccRes['choices'][0]['message']['content'] ?? '{}';
        $tree    = $safeExtractJson($rawTree);

        // Si el modelo no respetó el formato, asegúrate de tener un nodo raíz válido
        if (empty($tree) || !is_array($tree)) {
            $tree = [
                "topic"       => "Root",
                "description" => "Autogenerated root for {$userInput}",
                "children"    => [],
            ];
        }

        // ----------------------
        // STEP 3 — Embed each idea & compute similarities (robusto)
        // ----------------------
        $ideas = [];
        $collectIdeas($tree, $ideas); // a cualquier profundidad

        $semanticBridges = [];

        foreach ($ideas as $idea) {
            $text = '';
            if (!empty($idea['topic']))       $text .= $idea['topic'];
            if (!empty($idea['description'])) $text .= ($text ? ' — ' : '') . $idea['description'];
            if ($text === '') continue;

            $response = $client->post('embeddings', [
                'json'   => ["model" => "text-embedding-3-small", "input" => $text],
                'verify' => false,
            ]);
            $embIdeaRes   = json_decode($response->getBody()->getContents(), true);
            $ideaEmbedding = $embIdeaRes['data'][0]['embedding'] ?? [];

            $similarityToUser = $cosine($userEmbedding, $ideaEmbedding);

            $semanticBridges[] = [
                'idea'       => $idea,
                'embedding'  => $ideaEmbedding, // guardamos para pairwise
                'similarity' => $similarityToUser,
            ];
        }

        // Ordena por similitud al usuario
        usort($semanticBridges, fn($a, $b) => $b['similarity'] <=> $a['similarity']);

        // Toma top-N para evaluar pares
        $topIdeas = array_slice($semanticBridges, 0, 6);

        // Busca el mejor par idea-idea por similitud de embeddings
        $bestPair      = null;
        $bestPairScore = -INF;

        if (count($topIdeas) >= 2) {
            foreach ($topIdeas as $i => $ideaA) {
                foreach ($topIdeas as $j => $ideaB) {
                    if ($i >= $j) continue; // evita par duplicado/invertido
                    $score = $cosine($ideaA['embedding'], $ideaB['embedding']);
                    if ($score > $bestPairScore) {
                        $bestPairScore = $score;
                        $bestPair      = [$ideaA, $ideaB];
                    }
                }
            }
        }

        // Fallbacks para no romper Step 4
        if (!$bestPair && count($semanticBridges) >= 2) {
            $bestPair = [$semanticBridges[0], $semanticBridges[1]];
        }
        if (!$bestPair && count($semanticBridges) === 1) {
            $bestPair = [$semanticBridges[0]]; // 1 sola idea
        }
        if (!$bestPair) {
            // No hay ideas válidas: devuelve error amigable
            response()->json([
                "input"          => $userInput,
                "idea_tree_raw"  => $rawTree,
                "idea_tree"      => $tree,
                "error"          => "No ideas found in idea_tree (model likely returned invalid/empty JSON)."
            ], 422);
            return;
        }

        $chosenBridge = $bestPair;

        // ----------------------
        // STEP 4 — Create strange twist (maneja 1 o 2 ideas)
        // ----------------------
        $descA = $chosenBridge[0]['idea']['description'] ?? ($chosenBridge[0]['idea']['topic'] ?? '');
        $descB = $chosenBridge[1]['idea']['description'] ?? ($chosenBridge[1]['idea']['topic'] ?? '');

        if (!isset($chosenBridge[1])) {
            $twistPrompt = <<<PROMPT
The user's goal is: "{$userInput}".

We have one key idea:
- {$descA}

Create a merged concept that's possible with technology up to today,
while ensuring it is still useful for achieving the user's goal.
Keep the explanation short and clear.
PROMPT;
        } else {
            $twistPrompt = <<<PROMPT
The user's goal is: "{$userInput}".

We have two semantically related ideas:
1) {$descA}
2) {$descB}

Merge these ideas into one coherent, logical, and possible, concept,
while ensuring it is still useful for achieving the user's goal.
Keep the explanation short and clear.
PROMPT;
        }

        $response = $client->post('chat/completions', [
            'json'   => [
                "model"    => "gpt-4o-mini",
                "messages" => [
                    ["role" => "system", "content" => "You are an objective logical cold, bold and unemotional entity that creates ideas based on inputs."],
                    ["role" => "user",   "content" => $twistPrompt],
                ],
                "temperature" => 0.6,
            ],
            'verify' => false,
        ]);
        $twRes       = json_decode($response->getBody()->getContents(), true);
        $twistedIdea = (string) ($twRes['choices'][0]['message']['content'] ?? '');

        // ----------------------
        // STEP 5 — Manual for twisted idea
        // ----------------------
        $manualPrompt = <<<PROMPT
You are a console that has access to an unknown vault of knowledge. You reply in a computer manner, with ascii characters, ">" indicating processes, steps and more. You have a lot of internal ideas in your vault that you must write as a manual of construction, it has to look like a classified file.

Write a detailed instruction manual for building and implementing the following idea:

<idea>
{$twistedIdea}
</idea>

The user's goal is: {$userInput}

Follow this framework for the manual.

>file-type: (define a random file type)]
>user-input: (the input of the user)]
>persona: (in a robotic and as an entity that's cold and bold and direct and truthsayer, make fun of the user in one sentence )
======
>void mode initiated:
(the manual only focused on the building steps, no testing, nothing that isn't building it)
======
>task finished
PROMPT;

        $response = $client->post('chat/completions', [
            'json'   => [
                "model"    => "gpt-4o",
                "messages" => [
                    ["role" => "system", "content" => "You produce clear, concise manuals."],
                    ["role" => "user",   "content" => $manualPrompt],
                ],
                "temperature" => 0.7,
            ],
            'verify' => false,
        ]);
        $manRes = json_decode($response->getBody()->getContents(), true);
        $manual = (string) ($manRes['choices'][0]['message']['content'] ?? '');
        $manual = $sanitizePlain($manual);

        $ideasDir = realpath(__DIR__ . '/../../public');

        // Si no existe la carpeta ideas, la creamos
        $ideasDir .= '/ideas';
        if (!is_dir($ideasDir)) {
            if (!mkdir($ideasDir, 0775, true) && !is_dir($ideasDir)) {
                throw new \Exception("No se pudo crear el directorio: $ideasDir");
            }
        }

        // Generar nombre único
        $filename = 'idea_' . time() . '.txt';
        $filePath = $ideasDir . '/' . $filename;

        // Guardar el archivo
        if (file_put_contents($filePath, $manual) === false) {
            throw new \Exception("No se pudo escribir el archivo: $filePath");
        }

        // URL pública
        $ideasUrl = '/ideas/' . $filename;


        // ----------------------
        // Final Output
        // ----------------------
        response()->json([
            "input"              => $userInput,
            "idea_tree"          => $tree,
            "semantic_bridges"   => $semanticBridges,   // incluye embeddings de ideas
            "chosen_bridge"      => $chosenBridge,      // par elegido (o 1 idea)
            "twisted_idea"       => $twistedIdea,
            "manual"             => $manual,
            "manual_url"          => $ideasUrl
        ]);
    } catch (\Throwable $e) {
        response()->json([
            "error"   => "Unhandled server error",
            "message" => $e->getMessage(),
            "trace"   => $e->getTraceAsString(),
        ], 500);
    }
});


// ...tus rutas previas

app()->get('/archive', function () {
    // /nytheria/app/routes  -> subir 2 niveles -> /nytheria
    $root       = dirname(__DIR__, 2);
    $publicPath = $root . '/public';
    $ideasDir   = $publicPath . '/ideas';

    if (!is_dir($ideasDir)) {
        @mkdir($ideasDir, 0775, true);
    }

    $glob = glob($ideasDir . DIRECTORY_SEPARATOR . '*.txt') ?: [];

    // helper tamaño legible
    $humanSize = function ($bytes) {
        $u = ['B', 'KB', 'MB', 'GB'];
        $i = 0;
        while ($bytes >= 1024 && $i < count($u) - 1) {
            $bytes /= 1024;
            $i++;
        }
        return sprintf('%.1f %s', $bytes, $u[$i]);
    };

    $files = [];
    foreach ($glob as $path) {
        $name = basename($path);
        $mtime = @filemtime($path) ?: time();
        $size  = @filesize($path) ?: 0;

        $files[] = [
            'name'        => $name,
            'size'        => $size,
            'size_h'      => $humanSize($size),
            'mtime'       => $mtime,
            'modified_h'  => date('Y-m-d H:i', $mtime),
            'url'         => '/ideas/' . rawurlencode($name), // público
        ];
    }

    usort($files, fn($a, $b) => $b['mtime'] <=> $a['mtime']);

    // Render Blade
    return render('archive', ['files' => $files]);
});
